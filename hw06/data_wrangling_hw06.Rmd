---
title: "Data Wrangling wrap up"
author: "Santiago David"
date: '2017-11-07'
output: github_document
---

- [Writing functions](#Writing-functions)

#### Load data and packages
```{r}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(broom))
data("gapminder")
```

# Writing functions

**Objective**: Write one (or more) functions that do something useful to pieces of the Gapminder or Singer data. Make it something thatâ€™s not trivial to do with the simple dplyr verbs.

**Process**: The homework provide a good starting point with the gapminder data following Jenny's [tutorial](http://stat545.com/block012_function-regress-lifeexp-on-year.html) to create a linear regression of life expectancy on year. However, 
First things first, let's plot the data!

```{r}
ggplot(gapminder, aes(year, lifeExp, colour = continent)) +
  geom_point() +
  facet_wrap(~ continent) +
  labs(title = "Life expectancy for each continent 1952-2007", x = "Years", y = "Life Expectancy (years)") +
  guides(colour = FALSE) +
  theme_classic() 
```

From these graphs, we can see that there is an increasing trend of life expectancy over years, However, a priori, we dont really know if the relationship is different for each country/continent, if the relationship between Life expectancy and year is linear, cuadratic, or whether a robust regression is more apropiate given the possibility that some values are outliers or influential observations. For example, what about that steep line of points in Europe?, or that odd red dot in Africa in the 90's?. For this reason, it is worth to create functions for different models that we can fit either to each continent, or country (or other similar data).

The ideal function, will be one that takes a variable `life expectancty` and `year` as input, fit a model, and return the coefficients `intercept`, and `slope` and potentially the `R-squared` as a way to understand how well the model fit the data...

####**Create some code**

We should start by fitting the models, and check how they behave by extracting the coefficients:

```{r}
# three models
linear1 <- lm(lifeExp ~ I(year - 1952), gapminder)
quadra1 <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), gapminder)
robust1 <- robustbase::lmrob(lifeExp ~ I(year - 1952), gapminder)
```

We have to use `I(year - 1952)` instead of just `year` to fix the intercept to life expectancy on year 1952 (following Jenny Bryan's [post](http://stat545.com/block012_function-regress-lifeexp-on-year.html))

Now, let's see the parameters

```{r}
#coefficients
coef(linear1)
coef(quadra1)
coef(robust1)
```

And the adjusted R-squared to get a sense of how close the data are to the fitted regression line
```{r}
#adjusted r squared
summary(linear1)$adj.r.squared
summary(quadra1)$adj.r.squared
summary(robust1)$adj.r.squared
```

Now, we see that the robust and quadratic models perform a bit better than the simple linear model. But remember this is for the `whole` data. Now, we want to create a function with that code that we can apply to subsets of the data.

####**Turn code into a function**

I can fit a function for each model separately... starting with the simple linear regression

```{r}
linear_mod <- function(dat, offset = 1952) {
  model <- lm(lifeExp ~ I(year - offset), dat)
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  adjusted_Rsquared <- summary(model)$adj.r.squared
  data.frame(intercept, slope, adjusted_Rsquared) %>% 
  setNames(c("Intercept", "Slope", "R-squared"))
}
```

Note, that here, we created an `offset` to specify an argument in the function, and defined specific objects for each parameter we are interested in, by extracting the first `[1]` and second `[2]` elements of the `coef` object and the `adj.r.squared` element of the summary object. We then create a data.frame with those value... 

Lets apply this function to the whole gapminder dataset.
```{r}
linear_mod(gapminder)
```

We can see that these values correspond to the values above (model = linear1), obtained by fitting a simple regression to Life expectancy and year to gapminder. So that's good, the function is doing what we think it is doing...

**Now** We can fix a separate function for the quadractic and robust regression models, or **even better**... Try to create a function that fit all three models at once, extract the three parameters of interest `intercept`, `slope`, and `R-squared` from each model and output a single table with those values...

```{r}
fit_all_models <- function(dat, offset = 1952) {
  # three models
  linear <- lm(lifeExp ~ I(year - offset), dat)
  quadra <- lm(lifeExp ~ I(year - offset) + I((year - offset)^2), dat)
  robust <- robustbase::lmrob(lifeExp ~ I(year - offset), dat)
  # parameters
  model <- c("Linear", "Quadratic", "Robust")
  intercept <- c(coef(linear)[1], coef(quadra)[1], coef(robust)[1])
  slope <- c(coef(linear)[2], coef(quadra)[2], coef(robust)[2])
  Adjusted_Rsquared <- c(summary(linear)$adj.r.squared, summary(quadra)$adj.r.squared, 
                         summary(robust)$adj.r.squared)
  # what we want for the output
  tibble(model, intercept, slope, Adjusted_Rsquared) %>% 
  setNames(c("Model", "Intercept", "Slope", "R-squared"))
}
```

Okay, let's see if it works for the whole gapminder... we should obtain exactly the same values we obtained in the first place, by fitting the three models to gapminder and extracting the values independently.

```{r}
fit_all_models(gapminder)
```

**Observations**: This function allows us to test three models at once to a set of data with a `Life expectancy` and `year` variables, extract the parameters of interest from each model and compared them easily in a single output table; So, now we can use this function to fit the models for each continent (or country)...

Let's try it for each continent, using the function `do`

```{r}
gapminder %>% 
  group_by(continent) %>% 
  do(fit_all_models(.)) %>% 
  knitr::kable(format = "markdown")
```

Now we can compare the `Intercept`, `Slope` and `Adjusted R-squared` per model for each continent with a single function that can be modified easily, if we want to extract something else from these models. Of course for statistical purposes, it is necessary to explore other aspects of these models, such as the estimated coefficients, F-test, etc... and not just the Adjusted R-squared values...

# Work with a nested data frame

**Objective**: Create a nested data frame and map a function over the list column holding the nested data.

**Process**: I will apply the function I created `fit_all_models` over a nested dataframe

```{r}
(gapminder %>% 
  group_by(continent, country) %>% 
  do(fit_all_models(.))) %>% 
  head() %>% 
  knitr::kable(format = "markdown")
```

First, we "nest" the data by continent and country, 

```{r}
gap_nested <- gapminder %>% 
  group_by(continent, country) %>% 
  nest()
head(gap_nested)
```

Apply function

```{r}
(map(gap_nested$data[1:2], fit_all_models))
```

```{r}
(gap_nested <- gap_nested %>% 
  mutate(model_fits = map(data, fit_all_models)))
```

```{r}
(gap_nested %>% 
   select(continent, country, model_fits) %>% 
   unnest(model_fits))
```






Another option using Broom... Explore later

{r}
tidy(linear_mod)
tidy(quadra_mod)
glance(quadra_mod)
tidy(robust_mod)


Another option for robust regression
{r}
library(robust)
robust <- robust::lmRob(lifeExp ~ I(year - 1952), gapminder)


