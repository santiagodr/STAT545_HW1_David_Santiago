---
title: "Data Wrangling wrap up"
author: "Santiago David"
date: '2017-11-07'
output: github_document
---

#### Load data and packages
```{r}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(forcats))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(broom))
data("gapminder")
```

# Writing functions

####**Objective**: 

Write one (or more) functions that do something useful to pieces of the Gapminder or Singer data. Make it something thatâ€™s not trivial to do with the simple dplyr verbs.

**Process**: The homework provide a good starting point with the gapminder data following Jenny's [tutorial](http://stat545.com/block012_function-regress-lifeexp-on-year.html) to create a linear regression of life expectancy on year. However, 
First things first, let's plot the data!

```{r}
ggplot(gapminder, aes(year, lifeExp, colour = continent)) +
  geom_point() +
  facet_wrap(~ continent) +
  labs(title = "Life expectancy for each continent 1952-2007", x = "Years", y = "Life Expectancy (years)") +
  guides(colour = FALSE) +
  theme_classic() 
```

From these graphs, we can see that there is an increasing trend of life expectancy over years, However, a priori, we dont really know if the relationship is different for each country/continent, if the relationship between Life expectancy and year is linear, cuadratic, or whether a robust regression is more apropiate given the possibility that some values are outliers or influential observations. For example, what about that steep line of points in Europe?, or that odd red dot in Africa in the 90's?. For this reason, it is worth to create functions for different models that we can fit either to each continent, or country (or other similar data).

The ideal function, will be one that takes a variable `life expectancty` and `year` as input, fit a model, and return the coefficients `intercept`, and `slope` and potentially the R-squared or Residual st error...

**Create some code**

We should start by fitting the models, and check how they behave by extracting the coefficients:

```{r}
# three models
linear_mod <- lm(lifeExp ~ I(year - 1952), gapminder)
quadra_mod <- lm(lifeExp ~ I(year - 1952) + I((year - 1952)^2), gapminder)
robust_mod <- robustbase::lmrob(lifeExp ~ I(year - 1952), gapminder)
```

We have to use `I(year - 1952)` instead of just `year` to fix the intercept to life expectancy on year 1952 (following Jenny Bryan's [post](http://stat545.com/block012_function-regress-lifeexp-on-year.html))

Now, let's see the parameters

```{r}
#coefficients
coef(linear_mod)
coef(quadra_mod)
coef(robust_mod)
```

And the adjusted R-squared to get a sense of how close the data are to the fitted regression line
```{r}
#adjusted r squared
summary(linear_mod)$adj.r.squared
summary(quadra_mod)$adj.r.squared
summary(robust_mod)$adj.r.squared
```

We see that the robust and quadratic models perform a bit better than the simple linear model. But remember this is for the `whole` data. Now, we want to create a function with that code that we can apply to subsets of the data.

**Turn code into a function**

I can fit a function for each model separately...

```{r}
linear_mod <- function(dat, offset = 1952) {
  model <- lm(lifeExp ~ I(year - offset), dat)
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  r2 <- summary(model)$adj.r.squared
  data.frame(intercept, slope, r2) %>% 
  setNames(c("Intercept", "Slope", "R-squared"))
  #return(c(intercept, slope, r2))
  #output <- list(intercept = intercept, slope = slope, r2 = r2)
  #return(output)
}
```

Lets apply the first function
```{r}
linear_mod(gapminder)
```

```{r}
gapminder %>% 
  group_by(continent) %>% 
  do(fit_all_models(.))
```

Or try to fit all models into the same function to get one single output

```{r}
fit_all_models <- function(dat, offset = 1952) {
  linear <- lm(lifeExp ~ I(year - offset), dat)
  quadra <- lm(lifeExp ~ I(year - offset) + I((year - offset)^2), dat)
  robust <- robustbase::lmrob(lifeExp ~ I(year - offset), dat)
  model <- c("Linear", "Quadratic", "Robust")
  intercept <- c(coef(linear)[1], coef(quadra)[1], coef(robust)[1])
  slope <- c(coef(linear)[2], coef(quadra)[2], coef(robust)[2])
  Adjusted_Rsquared <- c(summary(linear)$adj.r.squared, summary(quadra)$adj.r.squared, 
                         summary(robust)$adj.r.squared)
  data.frame(model, intercept, slope, Adjusted_Rsquared) %>% 
  setNames(c("Model", "Intercept", "Slope", "R-squared"))
  #return(c(intercept, slope, r2))
  #output <- list(intercept = intercept, slope = slope, r2 = r2)
  #return(output)
}
```

```{r}
fit_all_models(gapminder)
```





Another option using Broom... Explore later

```{r}
tidy(linear_mod)
tidy(quadra_mod)
glance(quadra_mod)
tidy(robust_mod)
```

Another option for robust regression
```{r}
library(robust)
robust <- robust::lmRob(lifeExp ~ I(year - 1952), gapminder)
```

